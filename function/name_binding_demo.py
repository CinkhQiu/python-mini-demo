"""
本示例用于说明 Python 中“赋值 / 参数传递”的本质语义：

核心结论：
1. Python 中变量不是“存值的盒子”，而是“名字（name）”
2. 赋值语句永远不会修改对象，只会让名字重新绑定到对象
3. 是否影响调用方，取决于：
   - 对象是否可变
   - 操作是“修改对象”还是“重新绑定名字”

只要出现 =（赋值语句），语义上一定是“名字重新绑定”。
是否“绑定回原有对象”，不改变“重新绑定”这个事实。

这一步有没有 = ？
    有 → 一定是重新绑定
这个对象支不支持“原地修改”？
    支持 → 可能改对象
    不支持 → 一定新建对象 + 重新绑定
"""


# ============================================================
# 示例一：可变对象（list）
# ============================================================
def append_element(lst):
    """
    lst 是一个局部名字，
    调用函数时，它与外部的 x 绑定到【同一个 list 对象】

    lst.append(5) 是“原地修改对象”的行为：
    - 对象本身发生变化
    - 没有发生重新绑定
    """
    print("  [append_element] id(lst):", id(lst))
    lst.append(5)   # 修改的是 list 对象本身


x = [1, 2, 3]
print("【可变对象 list】")
print("调用前:")
print("  x =", x)
print("  id(x):", id(x))

append_element(x)

print("调用后:")
print("  x =", x)
print("  id(x):", id(x))   # id 不变，说明对象没换

print("\n" + "=" * 60 + "\n")


# ============================================================
# 示例二：不可变对象（int）
# ============================================================
def add_one(val):
    """
    val 是一个局部名字，
    初始时与外部的 z 绑定到【同一个 int 对象】

    语句：val = val + 1 的本质是：
    1. 计算 val + 1，创建一个新的 int 对象
    2. 将名字 val 重新绑定到这个新对象

    注意：
    - int 是不可变对象，根本不存在“修改原对象”的可能
    - 这里只发生了名字的重新绑定
    """
    print("  [add_one] id(val) before:", id(val))
    val = val + 1          # 创建新对象 + 重新绑定名字
    print("  [add_one] id(val) after :", id(val))


z = 3
print("【不可变对象 int】")
print("调用前:")
print("  z =", z)
print("  id(3):", id(3))
print("  id(z):", id(z))

add_one(z)

print("调用后:")
print("  z =", z)          # z 未发生变化
print("  id(z):", id(z))  # id 不变，仍指向原来的 int 对象